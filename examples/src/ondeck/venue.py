# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: venue.sql
from collections.abc import AsyncIterator
import dataclasses
from typing import cast

import sqlalchemy
import sqlalchemy.ext.asyncio

from ondeck import models


CREATE_VENUE = """-- name: create_venue \\:one
INSERT INTO venue (
    slug,
    name,
    city,
    created_at,
    spotify_playlist,
    status,
    statuses,
    tags
) VALUES (
    :p1,
    :p2,
    :p3,
    NOW(),
    :p4,
    :p5,
    :p6,
    :p7
) RETURNING id
"""


@dataclasses.dataclass()
class CreateVenueParams:
    slug: str
    name: str
    city: str
    spotify_playlist: str
    status: models.Status
    statuses: list[models.Status] | None
    tags: list[str] | None


DELETE_VENUE = """-- name: delete_venue \\:exec
DELETE FROM venue
WHERE slug = :p1 AND slug = :p1
"""


GET_VENUE = """-- name: get_venue \\:one
SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
FROM venue
WHERE slug = :p1 AND city = :p2
"""


LIST_VENUES = """-- name: list_venues \\:many
SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
FROM venue
WHERE city = :p1
ORDER BY name
"""


UPDATE_VENUE_NAME = """-- name: update_venue_name \\:one
UPDATE venue
SET name = :p2
WHERE slug = :p1
RETURNING id
"""


VENUE_COUNT_BY_CITY = """-- name: venue_count_by_city \\:many
SELECT
    city,
    count(*)
FROM venue
GROUP BY 1
ORDER BY 1
"""


@dataclasses.dataclass()
class VenueCountByCityRow:
    city: str
    count: int


class AsyncQuerier[T: sqlalchemy.ext.asyncio.AsyncConnection | sqlalchemy.ext.asyncio.AsyncSession]:
    _conn: T

    def __init__(self, conn: T):
        self._conn = conn

    async def create_venue(self, arg: CreateVenueParams) -> int | None:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_VENUE), {
            "p1": arg.slug,
            "p2": arg.name,
            "p3": arg.city,
            "p4": arg.spotify_playlist,
            "p5": arg.status,
            "p6": arg.statuses,
            "p7": arg.tags,
        })).first()
        if row is None:
            return None
        return cast(int, row[0])

    async def delete_venue(self, *, slug: str) -> None:
        _ = await self._conn.execute(sqlalchemy.text(DELETE_VENUE), {"p1": slug})

    async def get_venue(self, *, slug: str, city: str) -> models.Venue | None:
        row = (await self._conn.execute(sqlalchemy.text(GET_VENUE), {"p1": slug, "p2": city})).first()
        if row is None:
            return None
        return models.Venue(
            id=cast(int, row[0]),
            status=cast(models.Status, row[1]),
            statuses=cast(list[models.Status] | None, row[2]),
            slug=cast(str, row[3]),
            name=cast(str, row[4]),
            city=cast(str, row[5]),
            spotify_playlist=cast(str, row[6]),
            songkick_id=cast(str | None, row[7]),
            tags=cast(list[str] | None, row[8]),
            created_at=cast(datetime.datetime, row[9]),
        )

    async def list_venues(self, *, city: str) -> AsyncIterator[models.Venue]:
        result = await self._conn.stream(sqlalchemy.text(LIST_VENUES), {"p1": city})
        async for row in result:
            yield models.Venue(
                id=cast(int, row[0]),
                status=cast(models.Status, row[1]),
                statuses=cast(list[models.Status] | None, row[2]),
                slug=cast(str, row[3]),
                name=cast(str, row[4]),
                city=cast(str, row[5]),
                spotify_playlist=cast(str, row[6]),
                songkick_id=cast(str | None, row[7]),
                tags=cast(list[str] | None, row[8]),
                created_at=cast(datetime.datetime, row[9]),
            )

    async def update_venue_name(self, *, slug: str, name: str) -> int | None:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_VENUE_NAME), {"p1": slug, "p2": name})).first()
        if row is None:
            return None
        return cast(int, row[0])

    async def venue_count_by_city(self) -> AsyncIterator[VenueCountByCityRow]:
        result = await self._conn.stream(sqlalchemy.text(VENUE_COUNT_BY_CITY))
        async for row in result:
            yield VenueCountByCityRow(
                city=cast(str, row[0]),
                count=cast(int, row[1]),
            )
